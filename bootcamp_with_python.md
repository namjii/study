# 1장. 변수


### 1. 메모리 미리보기

컴퓨터는 0과 1로 이루어진 데이터를 처리한다. 0과 1을 표현할 수 있는 데이터 단위를 비트라고 부른다. 
비트가 8개모이면 바이트라고 부른다 1바이트는 01011010과 같이 0과 1이 총 8개로 이루어져있다.

Bit  
Byte = 2^3 Bit  
KByte = 2^10 Byte  
MByte = 2^10 KByte  
GByte = 2^10 MByte  
TByte = 2^10 GByte  
  
 
#### 1.1 32비트와 64비트의 의미  
컴퓨터는 데이터 단위로 비트를 사용한다. 데이터를 한번에 몇 개 보낼 수 있는지 나타내는 지표가 32비트와 64비트이다.
비트 수가 높을 수록 한 번에 보낼 수 있는 데이터 양이 많아진다. 또한 32비트 컴퓨터는 메모리 주소를 32비트로 표현하고 64비트 컴퓨터는 64비트로 표현한다.


#### 1.2 메모리 주소
32비트 컴퓨터라면 주소하나를 나타내는데 2진수 32자릿수를 사용한다. 그러므로 32비트에서 나타낼 수 있는 주소 갯수는 2의 32승(=4,294,967,296)개다.
이는 4GB이다. 그래서 32비트 컴퓨터를 사면 메모리를 추가로 사용해도 4GB까지밖에 사용할 수 없다.


### 2. 변수의 의미
변수란 데이터를 저장할 수 있는 메모리공간 그 자체를 뜻한다. 변수에는 숫자와 문자, 객체, 함수까지도 담을 수 있으며 값이나 가리키는 대상은 언제든 변경될 수 있다.
<pre><code>
int num = 5;           num[5]
</code></pre>

### 3. 파이썬에서의 변수: 이름과 값 객체
파이썬에서 변수라는 의미는 다른 언어와 다르다. 변수가 저장공간 그 자체가 아니라 그냥 이름만을 의미한다. 파이썬에서 쓰는 변수는 이름과 값으로 나뉘어진다. 
<pre><code>
num = 5           num--->[5]
</code></pre>




# 2장. 정수


### 1. 컴퓨터에서 수를 표현하는 방법

#### 1.1 10진수
수를 표현하는 데 총 10개의 숫자를 사용 - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  

#### 1.2 2진수 
수를 표현하는 데 0과 1만 사용  

#### 1.3 16진수
수를 표현하는 데 총 열여섯개의 숫자 사용 - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 + a, b, c, d, e, f  

### 2. 10진수를 2진수로 
ex) 25 / 2 = 12 ... 1  
    12 / 2 =  6 ... 0  
     6 / 2 =  3 ... 0  
     3 / 2 =  1 ... 1  
     => 11001
     
<code>ex) 25 = 2^3 + 2^2 + 2^0</code>
     => 11001
     
ex) >>> bin(25)  => 11001


### 3. 2진수를 10진수로

ex) 11001  
 => 1 * 2^4  +  1 * 2^3  +  0 * 2^2  +  0 * 2^1  + 0 * 2^0  
 => 16 + 8 + 0 + 0 + 1  
 => 25  

### 4. 16진수를 2진수로
16진수 -> 10진수 -> 2진수

> F     -> 15    -> 1111


### 5. 코딩으로 확인하는 진수변환 
<pre><code>
>>> a = 0xa
>>> bin(a)
>>> '0b1010'
</code></pre>

<pre><code>
>>> hex(0b00101101)
>>> '0x2d'
</code></pre>

### 6. 양의 정수
컴퓨터는 정수를 다양한 크기로 저장할 수 있다. 정수가 1바이트라고 가정하고 설명하면 양수와 음수 부호를 나타내는데 1비트를 사용한다. 
맨 앞의 비트가 0이면 양수, 1이면 음수다. 그리고 나머지 7개의 비트로 숫자를 표현한다. 


### 7. 음의 정수

#### 7.1 보수 개념
보수란 보충해 주는 수이다. 각 자리 숫자의 합이 어느 일정한 수가 되게하는 수이다.
10진수에서는 10의 보수법과 9의 보수법이 존재한다.(n진수 -> n의 보수, n-1의 보수 존재) 
7에대한 10의 보수는 7과 어떤 수를 더헀을 때 10이 되는지 계산한 수 3이다.
7에 대한 9의 보수는 2이므로 **10의 보수는 9의 보수 +1 과 같다**고 볼 수 있다. 

#### 7.2 2의 보수
이런 개념을 2진법에도 반영하여 음의 정수 개념을 2의 보수로 표현할 수 있다. 2진법의 보수에는 1의 보수와 2의 보수가 있다. 
10의 보수와 9의 보수처럼 2의 보수는 1의 보수에 +1 한것과 같다. 
1의 보수는 각자리에 더하면 1이 되는 숫자이기 때문에 결과적으로 2진수를 뒤집은 숫자와 같다.
> 1011 -> 0100

여기에서 2의 보수를 구하려면 +1만 시켜주면된다

> 0100 -> 0101

(참고: http://zapiro.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84%EB%B2%95%EB%B3%B4%EC%88%98%EB%B2%95)

#### 7.3 음수의 표현 
-4  ==2진수==>  0000 0100  ==1의보수==>  1111 1011  ==+1==>  1111 1100


#### 7.4 2의 보수로 표현하는 이유
- 양수와 음수를 같은 체계로 만들면 +0, -0 으로 0이 두개가 존재하게 된다. 이렇게 되면 낭비이고 두 수의 뺄셈을 할 때 +0과 -0을 비교하면 결과가 다르게 나올 수 있다 
- 컴퓨터에서 뺄셈을 할 때, 2의 보수 개념을 활용한다. 9-4 을 빼는 것이 아니라 실제로는 9+(-4)을 하게된다. 이를 실제 계산으로 해보면
 0000 1001 + 1111 1100 = 10000 0101 이 나오는데 앞의 1은 지워준다. 



# 4장. 문자열

### 1. 아스키코드
문자인코딩은 문자집합을 메모리에 저장하거나 통신하는데 사용하기 위해 부호화 하는 방식이다. 컴퓨터에 인식 시키려면 문자를 2진수로 나타내야하기 때문이다. 
아스키코드는 대표적인 문자인코딩 방식으로 비트 일곱개로 총 128개의 문자를 표현한다.

### 2. 유니코드
아스키 코드는 알파벳을 표현하는데에만 적합하기 때문에 한글이나 기타 언어를 표현하기위해서 유니코드가 쓰인다. 7비트에서 16비트까지 확장해 65,536개 문자를 표현할 수 있고 더 확장도 가능하다.



### 3. 유니코드 인코딩 방식
문자수가 많아질 것을 대비하여 크게는 크기별로 utf8, utf16, utf32로 나뉘었다. 

#### 3.1 UTF-8
유니코드 문자 하나를 1바이트에서 4바이트 사이에서 표현하는 방식. 문자에 따라서 바이트수가 달라지므로 가변길이 인코딩 방식이다. 
문자열 "가" 는 유니코드의 코드포인트로 AC00이다. utf8에서 0800~FFFF사이의 문자는 다음과 같은 포맷으로 변경된다.
<pre><code>
1110XXXX 10XXXXXX 10XXXXXX
</code></pre>
앞의 3자리는 사용바이트수를 나타내며 X로 표현된 부분에는 AC00을 2진수로 변환한 후 차례대로 채운다. 
AC00을 2진수로 변환하면 1010 1100 0000 0000 이며 순서대로 채우면 아래와 같다.
<pre><code>
11101010 10110000 10000000
</code></pre>
이 결과를 16진수로 다시 변환하면 3바이트 결과값인 0xEAB080이 된다.


#### 3.2 UTF-16
2바이트, 4바이트 단위로 문자를 표현한다. 코드 유닛의 크기는 16비트이다. 유니코드 값은 유니코드의 코드포인트 값을 순서만 바꾼 모습이다.
<pre><code>
"가" -> AC00 -> 00 AC
</code></pre>

#### 3.3 UTF-32
모든 문자를 4바이트로 표현한다. 코드유닛의 크기는 32비트이다. 
<pre><code>
"가" -> AC00 -> 00 AC 00 00
</code></pre>


### 4. 파이썬 문자열의 특징
C언어에서는 문자열을 변수로 만들면 문자를 변경할 수 있고 상수로 만들면 변경할 수 없지만, 파이썬에서는 무조건 문자열을 변경할 수 없다.
더하거나 고쳐도 새로 메모리에 할당되는 형식이지 원래 있던 값이 변경되지 않는다. 



# 5장. 함수

### 1. 함수를 시작하기 전에 

#### 1.1 자료구조
- 스택 : 데이터를 접시처럼 차곡차곡 쌓아올리고, 사용할 때는 맨위부터 차례차례 꺼내는 구조. 마지막에 들어온 데이터가 가장 먼저 나가게 된다.


#### 1.2 전역변수와 지역변수
- 전역변수 : 전체 영역에서 접근할 수 있는 변수. 함수안에서도 접근할 수 있다.
<pre><code>
g_var = 10

def func():
	print(g_var)
</code></pre>

함수 안에서 전역변수 변경은 불가능 하다
<pre><code>
g_var = 10

def func():
	g_var = 20
	print(g_var)
print(g_var)
</code></pre>
><pre>20<code>
</code>10</pre>


# 6장 객체지향 프로그래밍

__객체지향의 3요소 상속/다형성/캡슐화__

### 4. 객체지향 프로그래밍
이 프로그램이 무슨일을 하는가에 대한 대답을 알려준 절차지향과 달리 객체지향은 __현실에 존재하는 객체를 어떻게 모델링할 것인가__에 대한 물음에서 시작한다. 

#### 4.1 캡슐화
모든사람이 키, 나이, 몸무게, 성별과 같은 특성을 가지고있지만 그 값은 저마다 다르다. 이런 특성값 하나하나가 모여 나라는 객체를 만든다.
또한 사람은 잠자기, 숨쉬기, 말하기 같은 행동을 할수도 있다. 이처럼 객체는 고유의 특성값과 행동, 기능으로 표현할 수 있다. 
이것을 프로그래밍으로 정리하면 특성들은 변수가 되고, 행동과 기능은 함수이다. 이렇게 현실세계를 모델링할 때 변수와 함수를 가진 객체를 이용하는 
패러다임을 객체지향이라고 하며, 변수와 함수를 하나의 단위로 묶는 것을 __캡슐화__라고 한다.

#### 4.2 클래스를 사용해 객체 만들기
컴퓨터에게 객체라는 메모리공간을 할당해서 객체 안 변수들을 초기하하고 함수를 호출하는데 필요한 것이 바로 클래스다.
클래스는 객체를 생성해내는 템플릿이고, 객체는 클래스를 이용해 만들어지니 변수와 함수를 지닌 메모리공간이다.
객체와 유사한 개념으로 인스턴스가 있다. 객체는 객체 자체에 초점을 맞춤 용어고, 인스턴스는 이 객체가 어떤 클래스에서 만들어졌는지에 초점을 맞춘 용어이다. 
ex) 이 객체는 Person 클래스의 인스턴스이다

- 클래스의 첫글자는 대문자로 하는 것이 관례이다.
- 클래스 내부의 변수를 __프로퍼티__, __멤버 변수__ 라고 부른다.
- <code> __init()__ </code> 함수는 인스턴스의 멤버변수를 초기화하는 특별한 역할을 하는 __생성자__라고 부르는 함수이다.
- 파이썬에서 앞뒤로 언더바 두개가 있는 팜수는 예약해두었다는 의미이다. 
- self 키워드는 객체 자신을 의미한다.
- 클래스에 있는 함수를 멤버함수, 메서드라고 부른다.
- 멤버변수와 멤버함수를 모두 속성(attribute)라고 부른다.

#### 4.3 파이썬의 클래스

- 함수와 메서드의 차이
<pre><code>
>>> type(Person.give_money)
<class 'function'>
>>> type(g.give_money)
<class 'method'>
</code></pre>

클래스의 함수는 class function, 인스턴스의 함수는 class method로 나온다.

<pre><code>
>>>dir(g.give_money)
['__self__', '__class__', '__func__', ...]
</code></pre>
give_money() 메서드의 속성에 이미 self 가 있기 때문에 사용할 때 self를 전달하지않아도된다.
<code>__func__</code>를 확인해보면 Person class의 함수라고 나온다. 

- 인스턴스 메서드와 클래스 메서드
<pre><code>
Class A:
  c_mem = 10  -> 클래스 멤버변수
  
  @classmethod -> 클래스 메서드로 만들어주는 데코레이터
  def cls_f(cls):
    print(cls.c_mem)
    
  def __init__(self, num):
    self.i_mem = num -> 인스턴스 멤버선언
    
  def ins_f(self):
    print(self.c_mem)
</code></pre>
객체가 멤버와 메서드를 가질 수 있는 것처럼 클래스도 멤버와 메서드를 가질 수 있다. 이를 각각 클래스멤버변수, 클래스 메서드라고한다.
클래스 멤버는 객체가 없어도 클래스를 통해서 바로 변수와 메서드에 접근가능하다. 인스턴스 메서드는 객체가 첫번째인자로 전달할 객체가 없기 때문에 호출할 수 없다. 
ex) A.c_mem, A.cls_f()

- 클래스 메서드와 정적 메서드 
<pre><code>
Class A:
  @staticmethod -> 정적 메서드
  def f():
    print('static method')
  
  @classmethod -> 클래스 메서드
  def g(cls):
    print('class method')
</code></pre>
정적 메서드는 인자로 클래스나 객체를 받지 않는다. 함수의 정의만 클래스 안에 있을 뿐 일반함수와 같으며 전역함수를 대체할 수도 있다.
클래스 메서드는 첫번째 인자로 클래스를 받는다. 생성자를 대체해서 사용할 수도 있다.


#### 4.5 정보은닉
캡슐화 할 때, 어떤 멤버변수와 메서드는 공개하여 유저 프로그래머가 사용할 수 있게 하고, 어떤 것은 숨겨서 접근할 수 없도록 해야할 것 인지 정하는 개념을 정보은닉이라고 한다. 
캡슐화는 정보은닉을 포함한 개념이다. C++이나 자바언어는 멤버변수를 선언할 때 외부에서 접근할 수 없도록 만드는 기능이 있어서 정보은닉을 구현할 수 있다. (private 키워드)
그러나 파이썬은 기본적으로 정보은닉을 지원하지 않는다. 그래서 약간의 편법(?)을 사용해 정보은닉을 구현한다.

- 숨기려는 멤버 앞에 언더바 두 개 붙이기 

<pre><code>
Class Account:
  def __init__(self, name, money):
    self.user = name
    self.__balace = money
    
  def get_balance(self):
    return self.__balance
    
  def set_balance(self, money):
    self.__balance = money

account = Account('greg', 5000)
</code></pre>
이 방법은 마치 정보은닉이 된것 처럼보이지만 실제로는 아니다. 
> account.__dict__  
> {'user': 'greg', '_Account__balance': 5000, '_ _balance': -3000}  

account._ _balance 로 접근하여 값을 수정할 수 있기 때문이다. _Account__balance 필드는 유저가 직접 만들지 않았지만 
멤버변수 이름에 언더바 두개가 붙어있다면 '_클래스이름'이 앞에 붙게된다.(맹글링) 결과적으로 이 방법은 마음만 먹으면 얼마든지 접근하여 변경할 수 있다.

- 숨기려는 멤버 앞에 언더바 한 개 붙이기  

주로 모듈 내부에서만 사용하는 private 클래스/함수/변수/메서드를 선언할 때쓰는 컨벤션이다. 이 컨벤션으로 선언하게 되면 외부에서 모듈전체를 import할 시에 언더바로 시작하는것은
모두 import에서 무시된다. 그러나 이 방법도 직접 가져다쓰거나 호출할 경우에는 사용이 가능하다.

- 프로퍼티 기법 
<pre><code>
class Account:
  @property
  def balance(self):
    return self._balance
    
  @property.setter
  def balance(self, money):
    self._balance = money
  
</code></pre>
프로퍼티를 이용하면 멤버에 접근하는 것 처럼 보이지만 사실은 메서드를 호출한다. 그러나 이방법도 유저프로그래머가 멤버변수로 바로 접근하는 것을 원천적으로 막을 수 없다.


# 7장 클래스

### 1. 클래스 관계

#### 1.1 IS-A: 상속
IS-A 는 '~는 ~의 한 종류'라는 의미. (ex: 노트북은 컴퓨터의 한 종류이다) IS-A관계를 프로그램에서 표현할 때 상속을 사용한다.
상속관계에서 상속을 하는 클래스를 기본클래스, 부모클래스, 슈퍼클래스라고 하며, 상속을 받는 클래스를 파생클래스, 자식클래스 서브클래스라고 한다.

<pre><code>
class Computer:
	pass

class Laptop(Computer):
	pass
</code></pre>

#### 1.2 HAS-A: 상속
HAS-A 관계는 '~이 ~을 가진다 혹은 포함한다'의 의미 (ex: 경찰은 총을 가지고있다)

<pre><code>
class Gun:
	pass

class Police():
	def __init__(self):
		self.gun = None
		
	def release_gun(self):
		gun = self.gun
		self.gun = None
		return gun
		
	def acquire_gun(self, gun):
		self.gun = gun
</code></pre>

### 2. 메서드 오버라이딩과 다형성

다형성이란 상속관계에 있는 다양한 클래스의 객체에서 같은 이름의 메서드를 호출할 때, 각 객체가 서로 다르게 구현된 메서드를 호출함으로써 서로 다른 작업을 수행하는 것이다. 
자식 클래스 안에서 상속받은 메서드를 다시 구현하는 것을 메서드 오버라이딩이라고 한다.

#### 2.1 메서드 오버라이딩

<pre><code>
class Car:
   def __init__(self, name):
      self.owner = name
   
   def drive(self):
      print('owner is driving')
      

class SelfDrivingCar(Car):
   def drive(self):
      print('car is driving by itself')

car = Car('smith')
car.drive()

s_car = SelfDrivingCar('john')
s_car.drive()
	
</code></pre>

> owner is driving
> car is driving by itself

#### 2.2 다형성
<pre><code>
class Animal:
   def eat(self):
      print('eat something')


class Salmon(Animal):
   def eat(self):
      print('eat plankton')
      
class Human(Animal):
   def eat(self):
      print('eat everything')
      
Animal().eat()
Salmon().eat()
Human().eat()
</code></pre>

> eat something
> eat plankton
> eat everything

eat()메소드는 다형성을 구현한 부분이다. 
애초에 유저프로그래머가 Animal 클래스의 인스턴스를 만들지못하게 하고싶다면 __추상클래스__ 로 구현하면된다.
추상클래스는 독자적으로 인스턴스를 만들수 없고 함수의 몸체가 없는 추상메서드를 하나이상 가지고있어야 한다. 추상클래스를 상속받은 자식클래스는 추상메서드를 반드시 오버라이딩해야한다. 그렇지않으면 자식도 추상클래스가된다. 추상메소드를 만들고 싶으면 메소드 정의 위에 데코레이터 __@abstractmethod__ 를 붙여준다.


#### 2.4 연산자 오버로딩
클래스 안에서 메서드로 연산자를 새롭게 구현하는 것으로 다형성의 특별한 형태이다. 파이썬에서는 앞뒤로 언더바 두개씩 붙은 예약함수가 존재한다. 
연산자 오버로딩이랑 인스턴스 객체끼리 서로 연산을 할 수 있게끔 기존에 있는 연산자의 기능을 바꾸어 중복으로 정의하는 것이다.


# 9장 메모리

### 1. 메모리 저장방식
메모리에 값이 저장될 때, 숫자를 왼쪽에서 오른쪽으로 저장하지않고, 오른쪽에서 왼쪽으로 저장하는데, 이 방식을 빅엔디언이라고 한다. 
왼쪽에서 오른쪽으로 저장하는 방식은 리틀엔디언이라고 한다.

### 2. 메모리 계층 
<pre><code>
레지스터
캐시
메모리
하드디스트
</code></pre>
레지스터는 가장 빠르지만 용량은 가장 작다. 레지스터가 하드디스크나 RAM보다 비싸기 때문이다. 이러한 이유로 메모리 계층 구조가 생겨났다.
메모리 계층구조에서는 위로올라갈 수록 속도는 빨라지지만 용량은 작아진다. 전달되는 데이터가 아래쪽에 있을경우 CPU는 모든 계층을 거쳐서 가야한다. 
그렇게 하면 속도가 느려질 것 같지만 지역성이라는 개념때문에 실제로 느리지않다.

### 3. 지역성과 캐시히트
캐시가 없을 때는 메모리에서 레지스터로 데이터를 바로가져왔는데 매번 멀리까지가서 가져오기가 부담스러워져서 캐시가 생겨났다. 
캐시는 레지스터와 메인메모리 사이에서 요청한 데이터만 가져오는것이 아니라 인접한 데이터들도 메모리블록(캐시 행)단위로 가져온다. 
캐시 행에 다음에 필요한 데이터가 있으면 이것을 캐시 히트라고 한다. 지역성의 원리 때문에 데이터 접근이 같은 메모리공간이나 인접 메모리공간에 자주일어나서 효율적이다.
지역성에는 특정데이터에 접근하면 곧 다시 그데이터에 접근할 가능성이 높다는 시간적지역성과, 접근할 데이터가 이전에 접근했던 데이터와 인접해있을 확률이 높다는 공간적 지역성이 있다.

### 4. 가상주소공간
<pre><code>
코드 - 프로그램 코드(함수, 클래스)
데이터 - 전역변수
힙 - 프로그래머가 자유롭게 메모리 할당/해제하는 공간. 가비지콜렉터가 없는 언어인데 프로그래머가 다쓴메모리를 해지 안할경우 메모리 누수 발생
스택 - 지역변수
</code></pre>
프로그램을 실행하면 하드디스크에있던 프로그램이 메인 메모리에 올라오면서 프로세스별로 32비트 운영체제 기준 4GB 메모리를 할당받는다. 이 메모리는 실제로 4GB는 아니지만 프로세스관점에서는 그만큼 할당한 것처럼 사용한다. 그중에 반은 커널영역으로 운영체제가 담당하고, 나머지 반은 실제프로그램이 담당하는 유저영역이다. 유저영역은 코드, 데이터, 스택, 힙 세그먼트로 나뉜다.

### 6. 가상메모리와 페이징

#### 6.1 가상메모리
가상메모리란 메인메모리를 확장하기 위해 페이지파일로 불리는 하드디스크의 일정부분을 메인메모리처럼 사용하는 것이다. 가상메모리 관리기법에는 가상주소를 쪼개는 기준에 따라 세그멘테이션 기법과 페이징 기법이 있다.

#### 6.2 MMU
프로세스에 주어지는 메모리공간을 가상주소공간이라고 한다. 가상주소공간에서의 메모리 주소를 __논리 주소__라고 하며, 메인메모리의 실제주소를 __물리 주소__라고 한다. 이 때 논리주소를 물리주소로 변환해야 하는데 이때 필요한 하드웨어가 CPU내부에 존재하는 MMU(Memory Management Unit)이다.


#### 6.3 페이징
페이징 기법에서는 가상주소공간과 메인 메모리를 일정한 크기로 나눈다. __가상주소공간__ 의 쪼개진 한 부분을 페이지라고 부른다. 페이지 갯수가 많기 때문에 페이지 순서를 나타내는 비트가 필요한데 이것을 페이지 넘버 혹은 VPN(Virtual Page Number)라고 한다. 페이지 논리주소는 이 페이지 번호와 오프셋으로 구성되어있다. 오프셋은 페이지넘버가 그리키는 페이지의 첫 주소부터 실제주소까지의 거리이다.

#### 6.4 페이지 프레임
__메인 메모리__ 도 가상주소공간과 같은 크기로 쪼갠 한 부분을 페이지 프레임이라고 부른다. 프레임 순서를 나타내는 비트를 프레임넘버 혹은 PPN(Physical Page Number)라고 한다. 오프셋의 개념은 페이지와 똑같다. 

#### 6.5 페이지 테이블
페이지 테이블은 어떤 프로세스의 페이지 넘버(VPN), 상응하는 프레임 넘버(PPN), 상태 등을 저장하는 테이블이다. 

논리주소(VPN, offset) -> 페이지 테이블 -> 물리주소(PPN, offset)

#### 6.6 요구 페이징
가상 메모리는 요구 페이징으로 구현한다. 요구페이징이란 프로세스를 실행할 때 모든 페이지를 프레임에 매핑하는 것이 아니라, 필요한 페이지만 메인메모리에 올려실행하는 것이다.

#### 6.7 페이지 폴트
페이지 폴트는 CPU가 요청한 페이지가 메인 메모리에 없을 때 발생한다. 페이지 폴트가 발생하면 해당 페이지를 하드디스크에서 가져와 빈 프레임에 할당한다. 그런데 만약 메인메모리에 빈 프레임이 없다면 __페이지 교체 알고리즘__ 에 따라서 메인메모리에 있는 페이지를 하드디스크로 내리고 요청된 페이지를 메인메모리에 올린다.

#### 6.8 변환 색인 버퍼
변환색인 버퍼(Translation Lookaside Buffer, TLB)는 주소변환 속도를 높이기 위한 일종의 캐시이다. 최근사용한 페이지 테이블의 일부가 저장되어있어, MMU가 페이지 테이블에서 프레임넘버를 읽어와야할 때 먼저 TLB에 해당하는 항복이 있는지 확인한다.



# 10장. 프로세스와 스레드

### 1. 프로세스

- 프로그램 : 하드디스크에 저장된 실행파일

- 프로세스 : 하드디스크에서 메인 메모리로 코드와 데이터를 가져와 현재 실행되고 있는 상태. 한 프로그램을 2개 실행하면 프로세스도 2개 생성됨


#### 1.1 프로세스 상태

CPU는 한번에 하나의 프로세스에만 할당할 수 있다. 여러 프로세스가 동시에 실행되는것 같이 보이지만 실제로는 불가능하다.

1. 생성(created)
: 프로그램이 바로 실행되지 않고 ‘실행가능 상태’가 된다. 실행 순서를 기다리는 상태.

2. 실행가능(waiting)
: 운영체제는 인터럽트가 발생했을 때 실행가능 상태의 프로세스 중 다음으로 실행될 프로세스를 결정하고 실행중인 프로세스와 교체한다.

3. 실행(running)
: 프로세스가 운영체제로부터 CPU를 할당받아 실행

4. 보류(blocked)
: 프로세스가 입출력 작업을 하면 CPU를 해제하고 보류상태로 변경한다. 보류상태에 들어간 프로세스는 입출력작업이 모두 끝나면 실행가능상태로 변경된다.

5. 소멸(terminated)
: 프로세스 실행완료. 메인메모리에서 사라진다.


#### 1.2 프로세스 스케줄링
운영체제가 여러 프로세스의 CPU 할당순서를 결정하는 것

1. 우선순위 알고리즘
: 프로세스에 우선순위를 매겨 우선순위가 높은 프로세스를 먼저 실행. 계속 높은 우선순위의 프로세스가 생성되면 우선순위가 낮은 프로세스는 계속해서 CPU를 할당받지 못하는 기아상태(starvation) 발생. 그래서 우선순위가 낮은 프로세스도 턴이 지날 때마다 우선순위를 높여서 실행될 수 있도록 하는 방법을 에이징(aging) 이라고 한다.

2. 라운드 로빈 알고리즘
: 실행가능 상태에 있는 프로세스를 순서대로 가져와서 일정 타임슬라이스 단위로 CPU를 할당하는 방식. 선점형 스케줄링 방법. 타임슬라이스가 너무 짧으면 컨텍스트스위칭이 너무 자주일어나는 단점이 있다.

3. FCFS(First Come First Served)
: 먼저 들어온 프로세스를 먼저 실행하는 방법

4. SJF(Shortest Job First)
: 평균대기시간을 최소화하기 위해 CPU 할당시간이 짧은 프로세스를 먼저 실행한다. 하지만 할당시간이 긴 프로세스는 계속해서 실행 되지 않는 기아상태에 빠질 수 있으며 프로세스를 실행해볼 때까지 실제할당시간을 알 수 없는 경우도 있다.


#### 1.3 컨텍스트 스위칭
: 프로세스가 실행상태에서 실행가능 상태로 변경될 때 이러한 정보를 메모리 어딘가에 저장해야 한다. 이러한 프로세스의 CPU상태와 프로세스의 상태를 저장해둔 메모리 블록을 __프로세스 제어블록(Process Control Block: PCB)__라고 한다.
실행 중인 프로세스의 CPU 상태정보를 그 프로세스의 PCB에 저장하고 곧 실행될 프로세스의 PCB에서 이전 CPU상태정보를 CPU로 가져오는 것을 __컨텍스트 스위칭__이라고 한다.
잦은 컨텍스트 스위칭은 시스템 성능을 떨어트린다.

### 2. 스레드
: 프로세스 안의 실행흐름의 단위로 스케줄러에 의해 CPU를 할당받을 수 있는 인스트럭션의 나열이다. 스레드는 프로세스의 PCB와 비슷한 개념으로 __스레드 제어블록(Thread Control Block:TCB)__에 각종 스레드 정보를 저장한다.
프로세스가 단일 스레드로만 작동하면 결과적으로 프로세스와 스레드의 차이가 없다.  

#### 2.1 멀티프로세스와 멀티 스레드
멀티프로세스에서는 프로세스별로 각각 코드, 데이터, 힙, 스택 영역을 갖는다. 
하지만 멀티스레드에서는 코드, 데이터, 힙 영역은 공유하고 스레드 별로 스택영역만 분리 되어있기 때문에 데이터를 쉽게 공유할 수 있다. 

#### 2.3 경쟁조건
멀티스레드를 구현할 때 공유해서 쓸 수 있는 전역변수에 어떤 값을 스레드 별로 각각 수정하는 코드를 임계영역(critical section)이라고 한다. 이런 일이 일어나면 스레드에서 메모리에 변경된 값을 저장하기전에 다른 스레드에서 변경, 저장해서 결과가 올바르게 나오지 않는다. 이처럼 스레드 여러 개가 공유자원에 동시에 접근하는 것을 경쟁조건이라고 한다. 

#### 2.4 상호배제
경쟁조건을 해결하기 위해서는 상호배제(mutual exclusion)을 사용한다. 스레드 하나가 공유자원을 이용하는 동안에는 다른 스레드가 접근하지 못하게 막는것이다. 파이썬에서는 lock 객체를 활용한다.

* 파이썬의 전역 인터프리터 락 (Global Interpreter Lock : GIL)
파이썬에서 GIL을 쓰면 결과적으로 멀티코어를 사용해도 싱글코어를 사용하는 것과 같은 효과를 낸다. 하지만 GIL 때문에 멀티코어의 장점을 활용하지 못한다고 해도 멀티스레딩은 여전히 동시실행과 성능향상 때문에 사용된다.




# 12장 자료구조1

### 1. 자료구조
- 데이터를 효율적으로 검색/변경/삭제할 수 있도록 저장, 관리하는 방법.
- 가장 기본적인 자료구조로 배열(array)이 있다. 배열 안에 있는 변수 위치를 인덱스로 나타내어 변수에 매우 빠르게 접근할 수 있다. 때문에 검색이 빨라서 새로운 데이터 삽입이 없다면 배열이 효율적이다. 반면에 데이터 삽입이나 삭제가 자주일어난다면 연결 리스트(linked list)를 사용하는 것이 좋다.

#### 1.1 목표
자료를 어떻게 삽입/검색/삭제 하는지 이해하는 것

#### 1.2 추상 자료형
- 자료구조에서 삽입, 탐색, 삭제 등을 담당하는 함수들의 사용 설명서이다. 
- 실제로 구현한 형태가 아니라 인터페이스만 만든 상태

### 2. 연결리스트
데이터와 참조로 구성된 노드가 한 방향 또는 양방향으로 쭉 이어져 있는 자료구조

#### 2.1 노드
- 자료구조를 표현할 때 데이터를 담는 틀이다. 
- 단일 연결리스트에서는 저장할 데이터와 다음 노드를 가리키는 참조로 이루어져 있다.

#### 2.2 연결 리스트 구현
- 단일 연결리스트의 노드에는 참조가 하나만 있다. (다음것)
- 이중 연결리스트의 노드에는 다음 노드를 가리키는 참조와 이전 노드를 가리키는 참조가 있다.

##### 연결 리스트의 추상 자료형 
1. S.append(data) -> None
: 데이터 삽입. None return
2. S.search_target(target) -> (data, position)
: 데이터 검색. 데이터를 순회하며 대상 데이터를 찾아 위치와 함께 반환. 연결리스트에서는 위치가 있어도 배열처럼 바로 접근할 수 없고 순회하면서 이동해야한다.

3. S.search_pos(position) -> data
: 데이터 검색. 해당 위치에 있는 데이터 반환

4. S.remove(target) -> data
: 데이터 삭제. 리스트에서 대상 데이터를 찾아 먼저 발견하는 데이터를 지우면서 반환한다. 없으면 None.

5. S.empty -> bool
6. S.size -> integer

code:
https://github.com/namjii/study/blob/master/data_structure/LinkedList.py

### 3. 스택
- 스택은 데이터를 차곡차곡 쌓아올린 모습의 자료구조이다. 접시 쌓기에 비유하기도 한다. 
- 맨 마지막에 입력한 데이터를 가장 먼저 출력하는 LIFO(Last In First Out)방식이다.

#### 3.1 스택의 동작
- push : 삽입하는 동작이며, 맨 위에 쌓인다.
- pop : 맨 위에 있는 데이터를 삭제하면서 반환하는 동작

#### 3.2 스택 구현 
1. S.push(data) -> None
: 데이터를 스택의 맨 위에 추가
2. S.pop() -> data
: 스택의 맨위에 있는 데이터를 삭제하면서 반환
3. S.empty() -> bool
: 스택이 비었으면 참, 아니면 거짓을 반환
4. S.peek() -> data
: 스택의 맨 위에있는 데이터를 반환하되 삭제하지 않는 동작 

code:
https://github.com/namjii/study/blob/master/data_structure/ArrayStack.py


### 4. 큐
- 큐는 줄서기에 비유한다. 
- 먼저 들어온 데이터가 먼저 나가는 것을 FIFO(First In First Out)이라고 한다.

#### 5.1 큐의 동작
- 인큐(enquerre) : 큐에 데이터 삽입
- 디큐(dequeuer) : 큐에서 데이터를 꺼내는 것

#### 5.2 큐 구현
1. Q.enqueue(data) -> None
큐의 마지막에 데이터 추가

2. Q.dequeue() -> data
큐에서 가장 먼저 들어온 데이터를 삭제하며 반환

3. Q.empty() -> bool

4. Q.peek() -> data
: 큐에서 가장 먼저들어온 데이터를 삭제하지 않고 반환

code:
https://github.com/namjii/study/blob/master/data_structure/CircularQueue.py


##### 자료구조는 어떻게 결정해야 할까 
배열은 데이터 추가삭제보다 검색이 더 자주 일어날 때, 연결리스트는 검색보다 추가 삭제가 더 많이 일어날 때 사용한다.



# 13장 자료구조2

### 1. 재귀함수
재귀는 반복 또는 되풀이를 의미한다. 재귀 함수란 함수 정의 도중에 자기자신을 다시 호출하는 것이다. 무한으로 반복되지 않게하기 위해 탈출조건을 정의하는 것이 중요하다.

#### 1.1 팩토리얼
<pre><code>
def factorial(n):
    if n <= 1:
        return 1
    return factorial(n-1) * n
</code></pre>

#### 1.2 피보나치 수
code:
https://github.com/namjii/study/blob/master/data_structure/Fibonacci.py


### 2. 트리
- 트리의 정확한 정의는 사이클이 없는 연결된 그래프이다.
- 그래프의 일종으로 여러 노드가 한 노드를 가리킬 수 없는 구조이다.
- 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프 (그래프 개념은 나중에)

#### 2.1 사이클
순환하는 모양의 그래프로, 트리에는 사이클이 없어야한다.

#### 2.2 이진트리
- 이진 트리는 한 노드가 자식노드를 두 개 이하로만 갖는 트리이다. 
- 이진 트리의 노드도 데이터 부분 과 참조 부분으로 이루어져있는데, 자식 노드를 두 개씩 가질 수 있기 때문에 참조부분이 두 개인 구조이다.

- 부모노드 / 자식노드 : 다른 노드를 하위에 연결하고있는 노드 / 부모노드의 하위개념
- 루트노드 : 트리에서 최상위에 위치한 노드
- 링크 : 노드와 노드를 연결하는 선
- 인터널 노드 : 자식노드가 있는 노드
- 리프 노드 : 자식노드가 하나도 없는 노드

- 서브트리 : 상위 트리를 구성하는 한 요소. 전체 트리에서 중간 노드를 중심으로 일부분을 떼어낸 단위

- 트리레벨 : 노드의 깊이를 레벨이라고 한다. 루트노드는 0레벨이며 그 아래로 1레벨씩 내려간다.


#### 2.3 이진트리 종류
- 포화 이진트리 : 트리의 모든 레벨이 자식노드 2개씩 꽉 차있는 트리
- 완전 이진트리 : 아직 다 채워지지 않고 트리의 노드가 위에서 아래로, 왼쪽에서 오른쪽으로 채워지는 트리

### 3. 이진트리 순회
- 트리의 모든 노드를 중복하지 않으면서 순회하는 것. 
- 레벨이 여러단계인 트리에서는 아래의 방법과 재귀를 통해 모든 노드를 순회한다.

![binary_tree](https://user-images.githubusercontent.com/30254549/39104114-bc48ea0a-46e9-11e8-94b4-83608cbc1fbf.png)

1. 전위 순회 (preorder trabersal)
: 노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리

1 -> 2 -> 4 -> 5 -> 3 -> 6 -> 7

2. 중위 순회 (inorder traversal)
: 왼쪽 서브트리 -> 노드 -> 오른쪽 서브트리

4 -> 2 -> 5 -> 1 -> 6 -> 3 -> 7

3. 후위 순회 (postorder traversal)
: 왼쪽서브트리 -> 오른쪽 서브트리 -> 노드

4 -> 5 -> 3 -> 6 -> 7 -> 3 -> 1 


# 14장. 이진탐색트리

##### 이진탐색트리의 조건
1. 어떤 특정 노드를 선택했을 때 그 노드를 기준으로 왼쪽 서브트리에 존재하는 노드의 모든 데이터는 기준 노드보다 작고, 오른쪽 서브트리에 있는 모든 데이터는 기준 노드의 값보다 크다.
2. 이진 탐색트리는 중복데이터를 가질 수 없다 

### 2. 이진탐색트리의 구현 

#### 2.1 추상자료형
1. BST.insert(data) -> None
: 데이터 삽입. None return
2. BST.search(target) -> node
: 데이터 검색. 

3.BST.remove(target) -> node
: 데이터 삭제. 삭제하려는 노드가 리프노드인지 자식노드가 하나인지, 두개인지에 따라 삭제하는 방법이 다르다.

5. BST.insert_node -> None
: 데이터가 아니라 노드를 삽입. remove에서 반환받은 노드의 데이터를 수정한 후 다시 삽입할 때 사용.

#### 2.3 insert 메서드
삽입하려는 데이터를 루트노드부터 시작해 차례대로 비교해내려간다. 삽입데이터가 노드의 데이터보다 작으면 왼쪽 자식노드로 이동하고, 노드의 데이터보다 크면 오른쪽 자식노드로 이동해 다시 비교한다. 그렇게 내려오다보면 빈 노드를 만나는데, 이때 데이터를 삽입한다.

<img width="376" alt="2018-05-02 11 54 34" src="https://user-images.githubusercontent.com/30254549/39503255-e8afc718-4dff-11e8-8888-725a6f826b9c.png">

#### 2.4 search 메서드
insert와 유사하게 대상 데이터를 찾아 루트노드부터 비교하면서 내려온다. 대상 데이터를 찾으면 반환하고 아니면 None 리턴.

<img width="396" alt="2018-05-02 11 53 58" src="https://user-images.githubusercontent.com/30254549/39503256-eb587e74-4dff-11e8-8565-ff92202ab48d.png">

#### 2.5 remove 메서드
지우려는 대상 데이터를 찾고, 삭제할 노드의 상태에 따라 3가지 경우로 나누어지운다. 삭제하고 나서 빈자리를 메꿔야 하기 때문에 삭제된 노드의 데이터를 수정한 뒤에 다시 트리에 삽입한다.

- 삭제노드가 리프노드일 때
: 그냥 삭제하면됨
- 삭제노드의 자식노드가 하나일 때
: 삭제노드 자리에 자식노드를 위치시키고 삭제하면 됨
- 삭제노드의 자식노드가 두 개일 때 
: 왼쪽/오른쪽 자식노드중에 삭제노드를 대체할 노드를 찾는다.
왼쪽 자식노드로 대체할 경우 왼쪽 서브트리 중 제일 큰 값으로 대체한다.
오른쪽 자식노드로 대체할 경우 오른쪽 서브트리 중 제일 작은 값으로 대체한다.

# 15장 알고리즘

### 1. 알고리즘 성능분석 

#### 1.1 선형 탐색 알고리즘
대상 데이터와 저장되어있는 데이터를 순서대로 하나씩 비교하는 방식

#### 1.2 선형 탐색 알고리즘의 성능 
성능을 비교할 때는 최악의 경우로 계산한다. 선형 탐색 알고리즘은 데이터 갯수가 n개일 때 최대 n번까지 탐색해야 하므로 데이터 갯수와 비례해서 시간이 늘어난다.

#### 1.3 이진탐색 알고리즘 
대상 데이터와 가운데 위치한 데이터를 비교해서 대상 데이터가 작으면 비교 데이터의 이전 데이터를, 대상 데이터가 크면 비교 데이터의 이후 데이터를 같은 방식으로 반복해서 비교하는 방식 

#### 1.4 이진탐색 알고리즘의 성능 
데이터 갯수를 10개라고 할때 최대 3번만에 원하는 값을 찾을 수 있다. 이진 탐색 구조는 데이터를 한번 비교할 때마다 비교해야할 데이터 수가 반으로 줄어든다. 이진 탐색 알고리즘에서는 데이터가 n개이면 최대 log2 n 번만에 원하는 데이터를 찾을 수 있다.

#### 1.5 알고리즘의 성능 분석 
##### 빅오 방식
빅오는 데이터 갯수가 증가하면 연산횟수가 어떤 영향을 나타내는지 보여주는 개념이다.
- O(1): 1은 상수를 의미. 데이터가 증가해도 연산횟수가 항상같음
- O(n): 증가 형태가 선형이다. 데이터가 증가하면 비례하여 연산횟수고 증가
- O(log n): 증가 형태가 로그함수 그래프모양. 데이터가 증가해도 연산횟수 증가율이 매우 낮다.
- O(n*log n): 증가 형태가 선형과 로그형의 곱으로 나타난다. 선형 빅오보다는 성능이 떨어지지만 제곱보다는 낫다.
- O(n^2): 증가형태가 제곱. 데이터 갯수가 적을 때는 이용해도 괜찮지만 데이터 갯수가 조금만 많아져도 연산횟수가 급격히 늘어남.

##### 분할상환 분석 
특정상황에서는 좋지않은 성능을 내지만, 나머지 상황에서는 좋은 성능을 낼 때 모든 연산을 고려해 성능을 분석하는 것.

### 2. 정렬

#### 2.1 선택 정렬(selection sort)
1번째값 부터 마지막까지 돌아가면서 나머지 리스트와 비교한다. 비교하는 도중 나머지 리스트에 자신보다 작은 값이 있으면 교체한 후 리스트 마지막까지 비교한다. 그런 후 마지막 까지 남은 값이 처음에 나왔던 자리로 들어간다. 앞에서부터 작은 숫자 순서대로 정렬된다.

#### 2.2 삽입 정렬(insertion sort)
![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Insertion_sort_001.PNG)

1번째 값부터 시작하여 순차적으로 오른쪽값으로 넓혀가면서 새로운 값을 왼쪽에 있는 값들과 비교하며 자기자리를 찾아가는 정렬방법

#### 2.3 버블 정렬(bubble sort)
정렬되지않은 리스트에서 맨 앞에 위치한 데이터부터 차례로 두개씩 비교한다. 앞에 있는 데이터가 뒤에 있는 데이터보다 크면 두 데이터를 교환한다. 이렇게 한바퀴 돌면 맨 뒤에는 가장 큰데이터가 놓여지게된다. 앞의 데이터도 위 과정을 반복하면서 정렬한다.

#### 2.4 퀵 정렬(quick sort)
분할정복 알고리즘. 위 정렬들과 다르게 유일하게 log n의 효율을 보여준다. (나머지 정렬은 모두 n제곱의 효율). 파이썬에서 정렬함수를 쓰면 내부에서 퀵정렬을 실행한다.

정렬되지 않은 리스트에서 가운데있는 값을 피벗(pivot)으로 지정하고, 맨 처음 값을 left인덱스, 맨 마지막 값을 right인덱스로 둔다. left인덱스는 오른쪽으로 이동하다가 피벗값보다 큰 데이터를 만나면 멈추고, right인덱스는 왼쪽으로 이동하다가 피벗보다 큰데이터를 만나면 멈춘 후 두 데이터를 교환한다. left인덱스와 right인덱스가 교차할 때까지 반복하면 피벗을 중심으로 왼쪽은 작은값만 모이고 오른쪽은 큰값만 모인다. 
그러면 양쪽에서 동시에 퀵정렬을 다시 실행하여 정렬한다.


